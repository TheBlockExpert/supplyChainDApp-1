pragma solidity = 0.5.0;
import "../wineaccesscontrol/ConsumerRole.sol";
import "../wineaccesscontrol/GrowerRole.sol";
import "../wineaccesscontrol/ProducerRole.sol";
import "../wineaccesscontrol/RetailerRole.sol";
import "../wineaccesscontrol/WholesalerRole.sol";


contract SupplyChain is
    GrowerRole,
    ProducerRole,
    WholeSalerRole,
    RetailerRole,
    ConsumerRole
{

    // Define 'owner'
    address payable owner;

    // Define a variable called 'upc' for Universal Product Code (UPC)
    uint  upc;

    // Define a variable called 'sku' for Stock Keeping Unit (SKU)
    uint  sku;

    // Define a public mapping 'grapes' that maps the grapeID to a wine.
    mapping (uint => Grape) grapes;

    // Define a public mapping 'items' that maps the UPC to a wine.
    mapping (uint => Item) items;

    // Define a public mapping 'itemsHistory' that maps the UPC to an array of TxHash,
    // that track its journey through the supply chain -- to be sent from DApp.
    mapping (uint => string[]) itemsHistory;

    // Define enum 'GrapeState' with the following values:
    enum GrapeState
    {
        Harvested,  // 0
        ForSale,    // 1
        Sold,       // 2
        Shipped,    // 3
        Received    // 4
    }

    // Define enum 'WineState' with the following values:
    enum WineState
    {
        Produced,  // 0
        Packed,    // 1
        ForSale,   // 2
        Sold,      // 3
        Shipped,   // 4
        Received,  // 5
        Purchased   // 6
    }

    //TODO: set default states for grapes and items

    // Define a struct for grapes
    struct Grape {
        uint grapeId; // unique ID of grapes
        address payable ownerID;  // Metamask-Ethereum address of the current owner as the product moves through different stages
        address payable growerID; // Metamask-Ethereum address of the Grower
        string  growerName; // Grower Name
        string  growerInformation;  // Grower Information
        string  growerLatitude; // Grower plot Latitude
        string  growerLongitude;  // Grower plot Longitude
        uint    grapePrice; // Product Price
        GrapeState   grapeState;  // Grape State as represented in the enum above
    }

    // Define a struct 'Item' with the following fields:
    struct Item {
        uint    sku;  // Stock Keeping Unit (SKU)
        uint    upc; // Universal Product Code (UPC), generated by the Producer, goes on the package, can be verified by the Consumer
        address payable ownerID;  // Metamask-Ethereum address of the current owner as the product moves through different stages
        address payable producerID; // Metamask-Ethereum address of the Producer
        string  producerName; // Producer Name
        string  producerInformation;  // Producer Information
        string  producerLatitude; // Producer Latitude
        string  producerLongitude;  // Producer Longitude
        uint    productID;  // Product ID potentially a combination of upc + sku
        string  productNotes; // Product Notes
        uint    productPrice; // Product Price
        Grape[] grapes; // Array of grapes
        WineState   wineState;  // Product State as represented in the enum above
        address payable wholesalerID;  // Metamask-Ethereum address of the Wholesaler
        address payable retailerID; // Metamask-Ethereum address of the Retailer
        address payable consumerID; // Metamask-Ethereum address of the Consumer
    }

    // Define events for grapes
    event GrapeHarvested(uint grapeId);
    event GrapeForSale(uint grapeId);
    event GrapeSold(uint grapeId);
    event GrapeShipped(uint grapeId);
    event GrapeReceived(uint grapeId);
    // Define events for wine
    event WineProduced(uint upc);
    event WinePacked(uint upc);
    event WineForSale(uint upc);
    event WineForSold(uint upc);
    event WineForShipped(uint upc);
    event WineReceived(uint upc);
    event WinePurchased(uint upc);

    // Define a modifer that checks to see if msg.sender == owner of the contract
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    // Define a modifer that verifies the Caller
    modifier verifyCaller (address _address) {
        require(msg.sender == _address);
        _;
    }

    // Define a modifier that checks if the paid amount is sufficient to cover the price
    modifier paidEnough(uint _price) {
        require(msg.value >= _price);
        _;
    }

    // Define a modifier that checks the price and refunds the remaining balance
    modifier checkValue(uint _upc) {
        _;
        uint _price = items[_upc].productPrice;
        uint amountToReturn = msg.value - _price;
        items[_upc].consumerID.transfer(amountToReturn);
    }

    // Define a modifier that checks if an item.grapeState of a upc is Harvested
    modifier grapeHarvested(uint _grapeId) {
        require(grapes[_grapeId].grapeState == GrapeState.Harvested);
        _;
    }

    // Define a modifier that checks if an item.grapeState of a upc is ForSale
    modifier grapeForSale(uint _grapeId) {
        require(grapes[_grapeId].grapeState == GrapeState.ForSale);
        _;
    }

    // Define a modifier that checks if an item.grapeState of a upc is Sold
    modifier grapeSold(uint _grapeId) {
        require(grapes[_grapeId].grapeState == GrapeState.Sold);
        _;
    }

    // Define a modifier that checks if an item.grapeState of a upc is Shipped
    modifier grapeShipped(uint _grapeId) {
        require(grapes[_grapeId].grapeState == GrapeState.Shipped);
        _;
    }

    // Define a modifier that checks if an item.grapeState of a upc is Received
    modifier grapeReceived(uint _grapeId) {
        require(grapes[_grapeId].grapeState == GrapeState.Received);
        _;
    }

    // Define a modifier that checks if an item.wineState of a upc is Produced
    modifier wineProduced(uint _upc) {
        require(items[_upc].wineState == WineState.Produced);
        _;
    }

    // Define a modifier that checks if an item.wineState of a upc is Packed
    modifier winePacked(uint _upc) {
        require(items[_upc].wineState == WineState.Packed);
        _;
    }

    // Define a modifier that checks if an item.wineState of a upc is ForSale
    modifier wineForSale(uint _upc) {
        require(items[_upc].wineState == WineState.ForSale);
        _;
    }

    // Define a modifier that checks if an item.wineState of a upc is Sold
    modifier wineSold(uint _upc) {
        require(items[_upc].wineState == WineState.Sold);
        _;
    }

    // Define a modifier that checks if an item.wineState of a upc is Shipped
    modifier wineShipped(uint _upc) {
        require(items[_upc].wineState == WineState.Shipped);
        _;
    }

    // Define a modifier that checks if an item.wineState of a upc is Shipped
    modifier wineReceived(uint _upc) {
        require(items[_upc].wineState == WineState.Received);
        _;
    }

    // Define a modifier that checks if an item.wineState of a upc is Purchased
    modifier winePurchased(uint _upc) {
        require(items[_upc].wineState == WineState.Purchased);
        _;
    }

    // In the constructor set 'owner' to the address that instantiated the contract
    // and set 'sku' to 1
    // and set 'upc' to 1
    constructor() public payable {
        owner = msg.sender;
        sku = 1;
        upc = 1;
    }

    // Define a function 'kill' if required
    function kill() public {
        if (msg.sender == owner) {
            selfdestruct(owner);
        }
    }

}
